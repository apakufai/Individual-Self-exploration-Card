@app.route('/generate_and_download_pdf', methods=['POST'])
def generate_and_download_pdf():

    # Получаем данные из запроса
    jsonData = request.json
    print(jsonData)  # Для отладки
    
    userId = jsonData.get('userId')

    if session.get('isPDFGenerating', False):
            
        session['isPDFGenerating'] = True

        userGroup = jsonData.get('userGroup')
        userName = jsonData.get('userName')
        userSurname = jsonData.get('userSurname')
        userSex = jsonData.get('userSex')
        userBirthyear = jsonData.get('userBirthyear')
        userCategory = jsonData.get('userCategory')
        userEmail = jsonData.get('userEmail')

        adaptation_1 = int(jsonData.get('adaptation_1'))
        compromise_1 = int(jsonData.get('compromise_1'))
        bidding_1 = int(jsonData.get('bidding_1'))
        threat_1 = int(jsonData.get('threat_1'))
        logicArgument_1 = int(jsonData.get('logicArgument_1'))
        emotionsArgument_1 = int(jsonData.get('emotionsArgument_1'))
        adaptationCount_1 = float(jsonData.get('adaptationCount_1'))
        compromiseCount_1 = float(jsonData.get('compromiseCount_1'))
        biddingCount_1 = float(jsonData.get('biddingCount_1'))
        threatCount_1 = float(jsonData.get('threatCount_1'))
        logicArgumentCount_1 = float(jsonData.get('logicArgumentCount_1'))
        emotionsArgumentCount_1 = float(jsonData.get('emotionsArgumentCount_1'))

        adaptation_2 = int(jsonData.get('adaptation_2'))
        compromise_2 = int(jsonData.get('compromise_2'))
        threat_2 = int(jsonData.get('threat_2'))
        cooperation_2 = int(jsonData.get('cooperation_2'))
        avoidance_2 = int(jsonData.get('avoidance_2'))
        adaptationCount_2 = float(jsonData.get('adaptationCount_2'))
        compromiseCount_2 = float(jsonData.get('compromiseCount_2'))
        threatCount_2 = float(jsonData.get('threatCount_2'))
        cooperationCount_2 = float(jsonData.get('cooperationCount_2'))
        avoidanceCount_2 = float(jsonData.get('avoidanceCount_2'))

        adaptation_3 = int(jsonData.get('adaptation_3'))
        threat_3 = int(jsonData.get('threat_3'))
        cooperation_3 = int(jsonData.get('cooperation_3'))
        adaptationCount_3 = float(jsonData.get('adaptationCount_3'))
        threatCount_3 = float(jsonData.get('threatCount_3'))
        cooperationCount_3 = float(jsonData.get('cooperationCount_3'))

        understandingOfStyles_4 = int(jsonData.get('understandingOfStyles_4'))
        strengthInstallation_4 = int(jsonData.get('strengthInstallation_4'))
        manipulationInstallation_4 = int(jsonData.get('manipulationInstallation_4'))
        negotiationsInstallation_4 = int(jsonData.get('negotiationsInstallation_4'))
        strengthInstallationCount_4 = float(jsonData.get('strengthInstallationCount_4'))
        manipulationInstallationCount_4 = float(jsonData.get('manipulationInstallationCount_4'))
        negotiationsInstallationCount_4 = float(jsonData.get('negotiationsInstallationCount_4'))

        adaptation_5 = int(jsonData.get('adaptation_5'))
        bidding_5 = int(jsonData.get('bidding_5'))
        logicArgument_5 = int(jsonData.get('logicArgument_5'))
        emotionsArgument_5 = int(jsonData.get('emotionsArgument_5'))
        avoidance_5 = int(jsonData.get('avoidance_5'))
        adaptationCount_5 = float(jsonData.get('adaptationCount_5'))
        biddingCount_5 = float(jsonData.get('biddingCount_5'))
        logicArgumentCount_5 = float(jsonData.get('logicArgumentCount_5'))
        emotionsArgumentCount_5 = float(jsonData.get('emotionsArgumentCount_5'))
        avoidanceCount_5 = float(jsonData.get('avoidanceCount_5'))

        logicArgument_6 = int(jsonData.get('logicArgument_6'))
        emotionsArgument_6 = int(jsonData.get('emotionsArgument_6'))
        logicArgumentCount_6 = float(jsonData.get('logicArgumentCount_6'))
        emotionsArgumentCount_6 = float(jsonData.get('emotionsArgumentCount_6'))

        # ОБЩИЕ РЕЗУЛЬТАТЫ
        adaptation = adaptation_1 + adaptation_2 + adaptation_3 + adaptation_5
        adaptationCount = adaptationCount_1 + adaptationCount_2 + adaptationCount_3 + adaptationCount_5
        compromise = compromise_1 + compromise_2
        compromiseCount = compromiseCount_1 + compromiseCount_2
        bidding = bidding_1 + bidding_5
        biddingCount = biddingCount_1 + biddingCount_5
        threat = threat_1 + threat_2 + threat_3
        threatCount = threatCount_1 + threatCount_2 + threatCount_3
        logicArgument = logicArgument_1 + logicArgument_5 + logicArgument_6
        logicArgumentCount = logicArgumentCount_1 + logicArgumentCount_5 + logicArgumentCount_6
        emotionsArgument = emotionsArgument_1 + emotionsArgument_5 + emotionsArgument_6
        emotionsArgumentCount = emotionsArgumentCount_1 + emotionsArgumentCount_5 + emotionsArgumentCount_6
        strengthInstallation = strengthInstallation_4
        strengthInstallationCount = strengthInstallationCount_4
        manipulationInstallation = manipulationInstallation_4
        manipulationInstallationCount = manipulationInstallationCount_4
        negotiationsInstallation = negotiationsInstallation_4
        negotiationsInstallationCount = negotiationsInstallationCount_4
        cooperation = cooperation_2 + cooperation_3
        cooperationCount = cooperationCount_2 + cooperationCount_3
        avoidance = avoidance_2 + avoidance_5
        avoidanceCount = avoidanceCount_2 + avoidanceCount_5







        # Подключение к базе данных
        conn = get_db_connection()
        if conn is None:
            return "Не удалось подключиться к базе данных"
        cursor = conn.cursor()

        # СОЗДАНИЕ PDF
        temp_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'temp')
        os.makedirs(temp_dir, exist_ok=True)  # Создаем папку temp, если она не существует
        pdf_filename = f'ИКС-файл {userId}.pdf'  # Имя файла PDF
        # Абсолютный путь к директории, где находится файл шрифта
        base_dir = os.path.dirname(os.path.abspath(__file__))
        # Полный путь к файлу шрифта
        font_path = os.path.join(base_dir, 'static', 'fonts', 'Bahnschrift.ttf')
        # Проверка на существование файла шрифта
        if not os.path.isfile(font_path):
            return f"Файл шрифта не найден по пути: {font_path}", 404
        # Регистрация шрифта
        pdfmetrics.registerFont(TTFont('Bahnschrift', font_path))
        # Указываем полный путь к файлу в папке temp
        pdf_path = os.path.join(temp_dir, pdf_filename)
        
        # Создание холста
        can = canvas.Canvas(pdf_path, pagesize=A4)  # pdf_path для сохранения
        width, height = A4  # Размеры страницы
        can.setFont("Bahnschrift", 14)  # Установка шрифта и его размера


        # СТРАНИЦА 1
        image_path_1 = os.path.join(os.path.dirname(os.path.abspath(__file__)), "pagesPDF", "page_1.png")
        # Проверяем, существует ли изображение
        if not os.path.exists(image_path_1):
            print(f"Изображение {image_path_1} не найдено.")
        # Добавляем изображение на страницу
        can.drawImage(image_path_1, 0, 0, width=width, height=height)

        if userId and userId.strip():  # Проверяем, что поле не пустое
            can.drawString(75, (height - 696.345), str(userId))
        if userName and userName.strip():
            can.drawString(89.7, (height - 713.149), str(userName))
        if userSurname and userSurname.strip():
            can.drawString(122.5, (height - 730.049), str(userSurname))
        if userBirthyear and userBirthyear.strip():
            can.drawString(163.838, (height - 746.764), str(userBirthyear))
        if userCategory and userCategory.strip():
            can.drawString(129.7, (height - 763.5), str(userCategory))
        if userEmail and userEmail.strip():
            can.drawString(124.2, (height - 780.3), str(userEmail))

        
        can.showPage()  # Завершение первой страницы


        # СТРАНИЦА 2
        image_path_2 = os.path.join(os.path.dirname(os.path.abspath(__file__)), "pagesPDF", "page_2.png")
        # Проверяем, существует ли изображение
        if not os.path.exists(image_path_2):
            print(f"Изображение {image_path_2} не найдено.")
        # Добавляем изображение на страницу
        can.drawImage(image_path_2, 0, 0, width=width, height=height)

            # Функция рисования личного результата на горизонтальной шкале
        def rangeResultHorizontal(range_name, range_x_start, range_x_end, range_y_start, range_divisionsCount):
            # Вычисляем координаты X для "палочки"
            x_start = range_x_start + (((range_x_end - range_x_start) / range_divisionsCount) * range_name)
            y_start = height - range_y_start
            xLeft = -4
            xRight = 4
            yTop = 20
            yCenter = 16
            yBottom = 12
            can.setStrokeColorRGB(200 / 255, 65 / 255, 85 / 255)  # Устанавливаем цвет линии
            can.setLineWidth(1)  # Устанавливаем ширину линии
            can.setFillColorRGB(200 / 255, 65 / 255, 85 / 255) # Устанавливаем цвет заливки
            circle_radius = 0.5  # Радиус круга в пунктах
            can.circle(x_start, y_start, circle_radius, stroke=0, fill=1)  # Рисуется круг диаметром 1 пункт
            # Основная линия
            can.line(x_start, y_start, x_start, y_start + yBottom)
            # Остальные линии
            can.line(x_start, y_start + yBottom, x_start + xLeft, y_start + yCenter)
            can.circle(x_start + xLeft, y_start + yCenter, circle_radius, stroke=0, fill=1)
            can.line(x_start + xLeft, y_start + yCenter, x_start, y_start + yTop)
            can.circle(x_start, y_start + yTop, circle_radius, stroke=0, fill=1)
            can.line(x_start, y_start + yTop, x_start + xRight, y_start + yCenter)
            can.circle(x_start + xRight, y_start + yCenter, circle_radius, stroke=0, fill=1)
            can.line(x_start + xRight, y_start + yCenter, x_start, y_start + yBottom)

            # Функция рисования разброса по категории на горизонтальной шкале
        def rangeSpreadHorizontal(range_name_min, range_name_max, range_x_start, range_x_end, range_y_start, range_divisionsCount):
            # Координаты
            x_start_min = range_x_start + (((range_x_end - range_x_start) / range_divisionsCount) * range_name_min)
            x_start_max = range_x_start + (((range_x_end - range_x_start) / range_divisionsCount) * range_name_max)
            y_start = height - range_y_start
            yTopLine = 10
            xCorner = 2
            yCorner = 5
            can.setStrokeColorRGB(90 / 255, 127 / 255, 174 / 255)  # Устанавливаем цвет линии
            can.setLineWidth(1)  # Устанавливаем ширину линии
            can.setFillColorRGB(90 / 255, 127 / 255, 174 / 255) # Устанавливаем цвет заливки
            circle_radius = 0.5  # Радиус круга в пунктах
            # НАЧАЛО ОТРЕЗКА
            can.circle(x_start_min, y_start, circle_radius, stroke=0, fill=1)  # Рисуется круг диаметром 1 пункт
            can.line(x_start_min, y_start, x_start_min - xCorner, y_start + yCorner)  # Рисуется линия
            can.circle(x_start_min - xCorner, y_start + yCorner, circle_radius, stroke=0, fill=1)
            can.line(x_start_min - xCorner, y_start + yCorner, x_start_min, y_start + yTopLine)
            can.circle(x_start_min, y_start + yTopLine, circle_radius, stroke=0, fill=1)
            # КОНЕЦ ОТРЕЗКА
            can.circle(x_start_max, y_start, circle_radius, stroke=0, fill=1)  # Рисуется круг диаметром 1 пункт
            can.line(x_start_max, y_start, x_start_max + xCorner, y_start + yCorner)  # Рисуется линия
            can.circle(x_start_max + xCorner, y_start + yCorner, circle_radius, stroke=0, fill=1)
            can.line(x_start_max + xCorner, y_start + yCorner, x_start_max, y_start + yTopLine)
            can.circle(x_start_max, y_start + yTopLine, circle_radius, stroke=0, fill=1)
            # СОЕДИНИТЕЛЬНАЯ ЛИНИЯ
            can.line(x_start_min, y_start + yTopLine, x_start_max, y_start + yTopLine)
            
        # ЗНАЧЕНИЯ РАЗБРОСА ЗНАЧЕНИЙ ПО КАТЕГОРИИ
        if userCategory is not None and userCategory != "-":

            cursor.execute("SELECT MIN(adaptation_1) FROM ISeC_results WHERE userCategory = ?", (userCategory,))  # SQL-запрос
            result_min = cursor.fetchone()  # Сохраняем результат в переменную  
            adaptation_1_min = result_min[0] if result_min else None  # Первая строка из результата запроса
            cursor.execute("SELECT MAX(adaptation_1) FROM ISeC_results WHERE userCategory = ?", (userCategory,))  # SQL-запрос
            result_max = cursor.fetchone()  # Сохраняем результат в переменную  
            adaptation_1_max = result_max[0] if result_max else None  # Первая строка из результата запроса
            if adaptation_1_min is not None and adaptation_1_max is not None:
                rangeSpreadHorizontal(adaptation_1_min, adaptation_1_max, 69.033, 526.35, 517.673, 15)

            cursor.execute("SELECT MIN(compromise_1) FROM ISeC_results WHERE userCategory = ?", (userCategory,))  # SQL-запрос
            result_min = cursor.fetchone()  # Сохраняем результат в переменную  
            compromise_1_min = result_min[0] if result_min else None  # Первая строка из результата запроса
            cursor.execute("SELECT MAX(compromise_1) FROM ISeC_results WHERE userCategory = ?", (userCategory,))  # SQL-запрос
            result_max = cursor.fetchone()  # Сохраняем результат в переменную  
            compromise_1_max = result_max[0] if result_max else None  # Первая строка из результата запроса
            if compromise_1_min is not None and compromise_1_max is not None:
                rangeSpreadHorizontal(compromise_1_min, compromise_1_max, 69.033, 526.35, 754.016, 15)

        # РЕЗУЛЬТАТ РЕСПОНДЕНТА
        if adaptation_1 is not None:
            rangeResultHorizontal(adaptation_1, 69.033, 526.35, 517.673, 15)
        if compromise_1 is not None:
            rangeResultHorizontal(compromise_1, 69.033, 526.35, 754.016, 15)

        can.showPage()  # Завершение второй страницы


        # СТРАНИЦА 3
        image_path_3 = os.path.join(os.path.dirname(os.path.abspath(__file__)), "pagesPDF", "page_3.png")
        if not os.path.exists(image_path_3):
            print(f"Изображение {image_path_3} не найдено.")
            return
        can.drawImage(image_path_3, 0, 0, width=width, height=height)
            
        # ЗНАЧЕНИЯ РАЗБРОСА ЗНАЧЕНИЙ ПО КАТЕГОРИИ
        if userCategory is not None and userCategory != "-":

            cursor.execute("SELECT MIN(bidding_1) FROM ISeC_results WHERE userCategory = ?", (userCategory,))  # SQL-запрос
            result_min = cursor.fetchone()  # Сохраняем результат в переменную  
            bidding_1_min = result_min[0] if result_min else None  # Первая строка из результата запроса
            cursor.execute("SELECT MAX(bidding_1) FROM ISeC_results WHERE userCategory = ?", (userCategory,))  # SQL-запрос
            result_max = cursor.fetchone()  # Сохраняем результат в переменную  
            bidding_1_max = result_max[0] if result_max else None  # Первая строка из результата запроса
            if bidding_1_min is not None and bidding_1_max is not None:
                rangeSpreadHorizontal(bidding_1_min, bidding_1_max, 69.033, 526.35, 187.427, 15)

            cursor.execute("SELECT MIN(threat_1) FROM ISeC_results WHERE userCategory = ?", (userCategory,))  # SQL-запрос
            result_min = cursor.fetchone()  # Сохраняем результат в переменную  
            threat_1_min = result_min[0] if result_min else None  # Первая строка из результата запроса
            cursor.execute("SELECT MAX(threat_1) FROM ISeC_results WHERE userCategory = ?", (userCategory,))  # SQL-запрос
            result_max = cursor.fetchone()  # Сохраняем результат в переменную  
            threat_1_max = result_max[0] if result_max else None  # Первая строка из результата запроса
            if threat_1_min is not None and threat_1_max is not None:
                rangeSpreadHorizontal(threat_1_min, threat_1_max, 69.033, 526.35, 406.910, 15)

            cursor.execute("SELECT MIN(logicArgument_1) FROM ISeC_results WHERE userCategory = ?", (userCategory,))  # SQL-запрос
            result_min = cursor.fetchone()  # Сохраняем результат в переменную  
            logicArgument_1_min = result_min[0] if result_min else None  # Первая строка из результата запроса
            cursor.execute("SELECT MAX(logicArgument_1) FROM ISeC_results WHERE userCategory = ?", (userCategory,))  # SQL-запрос
            result_max = cursor.fetchone()  # Сохраняем результат в переменную  
            logicArgument_1_max = result_max[0] if result_max else None  # Первая строка из результата запроса
            if logicArgument_1_min is not None and logicArgument_1_max is not None:
                rangeSpreadHorizontal(logicArgument_1_min, logicArgument_1_max, 69.033, 526.35, 626.394, 15)

        # РЕЗУЛЬТАТ РЕСПОНДЕНТА
        if bidding_1 is not None:
            rangeResultHorizontal(bidding_1, 69.033, 526.35, 187.427, 15)
        if threat_1 is not None:
            rangeResultHorizontal(threat_1, 69.033, 526.35, 406.910, 15)
        if logicArgument_1 is not None:
            rangeResultHorizontal(logicArgument_1, 69.033, 526.35, 626.394, 15)

        can.showPage()  # Завершение третьей страницы


        # СТРАНИЦА 4
        image_path_4 = os.path.join(os.path.dirname(os.path.abspath(__file__)), "pagesPDF", "page_4.png")
        if not os.path.exists(image_path_4):
            print(f"Изображение {image_path_4} не найдено.")
            return
        can.drawImage(image_path_4, 0, 0, width=width, height=height)

        # ЗНАЧЕНИЯ РАЗБРОСА ЗНАЧЕНИЙ ПО КАТЕГОРИИ
        if userCategory is not None and userCategory != "-":
            
            cursor.execute("SELECT MIN(emotionsArgument_1) FROM ISeC_results WHERE userCategory = ?", (userCategory,))  # SQL-запрос
            result_min = cursor.fetchone()  # Сохраняем результат в переменную  
            emotionsArgument_1_min = result_min[0] if result_min else None  # Первая строка из результата запроса
            cursor.execute("SELECT MAX(emotionsArgument_1) FROM ISeC_results WHERE userCategory = ?", (userCategory,))  # SQL-запрос
            result_max = cursor.fetchone()  # Сохраняем результат в переменную  
            emotionsArgument_1_max = result_max[0] if result_max else None  # Первая строка из результата запроса
            if emotionsArgument_1_min is not None and emotionsArgument_1_max is not None:
                rangeSpreadHorizontal(emotionsArgument_1_min, emotionsArgument_1_max, 69.033, 526.35, 237.834, 15)

        # РЕЗУЛЬТАТ РЕСПОНДЕНТА
        if emotionsArgument_1 is not None:
            rangeResultHorizontal(emotionsArgument_1, 69.033, 526.35, 237.834, 15)

        # Идеальный профиль
        start_x_left = 141.732
        start_y_left = height - 785.197
        end_y_left = height - 484.996
        width_left = 141.732
        fullHeight_left = start_y_left - end_y_left
        values_left = [
            {"name": "Эмоции", "color": (133 / 255, 85 / 255, 85 / 255), "value": 5},
            {"name": "Логика", "color": (118 / 255, 102 / 255, 171 / 255), "value": 10},
            {"name": "Угроза", "color": (138 / 255, 171 / 255, 78 / 255), "value": 8},
            {"name": "Торги", "color": (200 / 255, 65 / 255, 85 / 255), "value": 13},
            {"name": "Компромисс", "color": (90 / 255, 127 / 255, 174 / 255), "value": 10},
            {"name": "Приспособление", "color": (235 / 255, 188 / 255, 109 / 255), "value": 4},
        ]
        current_y_left = start_y_left # Начальная позиция по Y для рисования каждой части графика в цикле for
        for part_left in values_left:
            if part_left["value"] > 0: # Проверяем, что значение больше 0
                # Рассчитываем высоту на основе значения
                height_left = (fullHeight_left * part_left["value"]) / sum(part["value"] for part in values_left)
                can.setStrokeColorRGB(*part_left["color"])
                can.setLineWidth(width_left)
                can.line(start_x_left, current_y_left, start_x_left, current_y_left - height_left)
                current_y_left -= height_left
        # Ваш профиль
        start_x_right = 453.543
        start_y_right = height - 785.197
        end_y_right = height - 484.996
        width_right = 141.732
        fullHeight_right = start_y_right - end_y_right
        values_right = [
            {"name": "Эмоции", "color": (133 / 255, 85 / 255, 85 / 255), "value": emotionsArgument_1},
            {"name": "Логика", "color": (118 / 255, 102 / 255, 171 / 255), "value": logicArgument_1},
            {"name": "Угроза", "color": (138 / 255, 171 / 255, 78 / 255), "value": threat_1},
            {"name": "Торги", "color": (200 / 255, 65 / 255, 85 / 255), "value": bidding_1},
            {"name": "Компромисс", "color": (90 / 255, 127 / 255, 174 / 255), "value": compromise_1},
            {"name": "Приспособление", "color": (235 / 255, 188 / 255, 109 / 255), "value": adaptation_1},
        ]
        current_y_right = start_y_right # Начальная позиция по Y для рисования каждой части графика в цикле for
        for part_right in values_right:
            if part_right["value"] > 0: # Проверяем, что значение больше 0
                # Рассчитываем высоту на основе значения
                height_right = (fullHeight_right * part_right["value"]) / sum(part["value"] for part in values_right)
                can.setStrokeColorRGB(*part_right["color"])
                can.setLineWidth(width_right)
                can.line(start_x_right, current_y_right, start_x_right, current_y_right - height_right)
                current_y_right -= height_right

        can.showPage()  # Завершение четвёртой страницы

        
        # СТРАНИЦА 5
        image_path_5 = os.path.join(os.path.dirname(os.path.abspath(__file__)), "pagesPDF", "page_5.png")
        if not os.path.exists(image_path_5):
            print(f"Изображение {image_path_5} не найдено.")
            return
        can.drawImage(image_path_5, 0, 0, width=width, height=height)
        if adaptation_2 is not None:  # Проверяем, что adaptation_2 не None
            can.drawString(230, (height - 254.286), str(adaptation_2))  # Печатаем текст (ДЧ)
        if compromise_2 is not None:  # Проверяем, что compromise_2 не None
            can.drawString(190.113, (height - 287.886), str(compromise_2))  # Печатаем текст (П)
        if threat_2 is not None:  # Проверяем, что threat_2 не None
            can.drawString(189, (height - 321.5), str(threat_2))  # Печатаем текст (Б)
        if cooperation_2 is not None:  # Проверяем, что cooperation_2 не None
            can.drawString(187.463, (height - 271.111), str(cooperation_2))  # Печатаем текст (В)
        if avoidance_2 is not None:  # Проверяем, что avoidance_2 не None
            can.drawString(196.658, (height - 304.686), str(avoidance_2))  # Печатаем текст (Р)
        # Параметры для линии
        can.setStrokeColorRGB(199 / 255, 65 / 255, 84 / 255)
        can.setLineWidth(5)
        can.setFillColorRGB(199 / 255, 65 / 255, 84 / 255)
        # Координаты точек
        soulman_x, soulman_y = 179.528, height - 424.016
        virtuoso_x, virtuoso_y = 429.921, height - 424.016
        politician_x, politician_y = 304.724, height - 549.212
        resident_x, resident_y = 179.528, height - 674.409
        berserker_x, berserker_y = 429.921, height - 674.409
        # Отступы
        axial_hei = 15 # Высота холма вертикальных линий
        axial_wid = 40 # Ширина пика холма вертикальных линий
        diagSmall_hei = 10 # Высота холма малых диагональных линий
        diagSmall_wid = 30 # Ширина пика холма малых диагональных линий
        diagBig_hei = 30 # Высота холма больших диагональных линий
        diagBig_wid = 100 # Ширина пика холма больших диагональных линий
        # Параметры оконечника стрелки
        arrow_length = 30  # Длина "крыльев" стрелки
        arrow_angle = math.radians(15)  # Угол в радианах

        # Душа-человек -> Виртуоз
        def soulman_to_virtuoso():
            can.line(soulman_x, soulman_y, ((soulman_x + virtuoso_x) / 2) - axial_wid, ((soulman_y + virtuoso_y) / 2) + axial_hei)
            can.circle(((soulman_x + virtuoso_x) / 2) - axial_wid, ((soulman_y + virtuoso_y) / 2) + axial_hei, 2.5, stroke=0, fill=1)
            can.line(((soulman_x + virtuoso_x) / 2) - axial_wid, ((soulman_y + virtuoso_y) / 2) + axial_hei, ((soulman_x + virtuoso_x) / 2) + axial_wid, ((soulman_y + virtuoso_y) / 2) + axial_hei)
            can.circle(((soulman_x + virtuoso_x) / 2) + axial_wid, ((soulman_y + virtuoso_y) / 2) + axial_hei, 2.5, stroke=0, fill=1)
            can.line(((soulman_x + virtuoso_x) / 2) + axial_wid, ((soulman_y + virtuoso_y) / 2) + axial_hei, virtuoso_x, virtuoso_y)
            # Координаты конца третьей линии
            line_end_x = ((soulman_x + virtuoso_x) / 2) + axial_wid
            line_end_y = ((soulman_y + virtuoso_y) / 2) + axial_hei
            can.line(line_end_x, line_end_y, virtuoso_x, virtuoso_y)
            # Вычисление направления линии
            dx = virtuoso_x - line_end_x
            dy = virtuoso_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = virtuoso_x
            arrow_tip_y = virtuoso_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(virtuoso_x, virtuoso_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(virtuoso_x, virtuoso_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)

        # Виртуоз -> Душа-человек
        def virtuoso_to_soulman():
            can.line(virtuoso_x, virtuoso_y, ((soulman_x + virtuoso_x) / 2) + axial_wid, ((soulman_y + virtuoso_y) / 2) - axial_hei)
            can.circle(((soulman_x + virtuoso_x) / 2) + axial_wid, ((soulman_y + virtuoso_y) / 2) - axial_hei, 2.5, stroke=0, fill=1)
            can.line(((soulman_x + virtuoso_x) / 2) + axial_wid, ((soulman_y + virtuoso_y) / 2) - axial_hei, ((soulman_x + virtuoso_x) / 2) - axial_wid, ((soulman_y + virtuoso_y) / 2) - axial_hei)
            can.circle(((soulman_x + virtuoso_x) / 2) - axial_wid, ((soulman_y + virtuoso_y) / 2) - axial_hei, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((soulman_x + virtuoso_x) / 2) - axial_wid
            line_end_y = ((soulman_y + virtuoso_y) / 2) - axial_hei
            can.line(line_end_x, line_end_y, soulman_x, soulman_y)
            # Вычисление направления линии
            dx = soulman_x - line_end_x
            dy = soulman_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = soulman_x
            arrow_tip_y = soulman_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(soulman_x, soulman_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(soulman_x, soulman_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)

        # Резидент -> Берсерк
        def resident_to_berserker():
            can.line(resident_x, resident_y, ((resident_x + berserker_x) / 2) - axial_wid, ((resident_y + berserker_y) / 2) + axial_hei)
            can.circle(((resident_x + berserker_x) / 2) - axial_wid, ((resident_y + berserker_y) / 2) + axial_hei, 2.5, stroke=0, fill=1)
            can.line(((resident_x + berserker_x) / 2) - axial_wid, ((resident_y + berserker_y) / 2) + axial_hei, ((resident_x + berserker_x) / 2) + axial_wid, ((resident_y + berserker_y) / 2) + axial_hei)
            can.circle(((resident_x + berserker_x) / 2) + axial_wid, ((resident_y + berserker_y) / 2) + axial_hei, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((resident_x + berserker_x) / 2) + axial_wid
            line_end_y = ((resident_y + berserker_y) / 2) + axial_hei
            can.line(line_end_x, line_end_y, berserker_x, berserker_y)
            # Вычисление направления линии
            dx = berserker_x - line_end_x
            dy = berserker_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = berserker_x
            arrow_tip_y = berserker_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(berserker_x, berserker_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(berserker_x, berserker_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)

        # Берсерк -> Резидент
        def berserker_to_resident():
            can.line(berserker_x, berserker_y, ((resident_x + berserker_x) / 2) + axial_wid, ((resident_y + berserker_y) / 2) - axial_hei)
            can.circle(((resident_x + berserker_x) / 2) + axial_wid, ((resident_y + berserker_y) / 2) - axial_hei, 2.5, stroke=0, fill=1)
            can.line(((resident_x + berserker_x) / 2) + axial_wid, ((resident_y + berserker_y) / 2) - axial_hei, ((resident_x + berserker_x) / 2) - axial_wid, ((resident_y + berserker_y) / 2) - axial_hei)
            can.circle(((resident_x + berserker_x) / 2) - axial_wid, ((resident_y + berserker_y) / 2) - axial_hei, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((resident_x + berserker_x) / 2) - axial_wid
            line_end_y = ((resident_y + berserker_y) / 2) - axial_hei
            can.line(line_end_x, line_end_y, resident_x, resident_y)
            # Вычисление направления линии
            dx = resident_x - line_end_x
            dy = resident_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = resident_x
            arrow_tip_y = resident_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(resident_x, resident_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(resident_x, resident_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)

        # Душа-человек -> Резидент
        def soulman_to_resident():
            can.line(soulman_x, soulman_y, ((soulman_x + resident_x) / 2) - axial_hei, ((soulman_y + resident_y) / 2) + axial_wid)
            can.circle(((soulman_x + resident_x) / 2) - axial_hei, ((soulman_y + resident_y) / 2) + axial_wid, 2.5, stroke=0, fill=1)
            can.line(((soulman_x + resident_x) / 2) - axial_hei, ((soulman_y + resident_y) / 2) + axial_wid, ((soulman_x + resident_x) / 2) - axial_hei, ((soulman_y + resident_y) / 2) - axial_wid)
            can.circle(((soulman_x + resident_x) / 2) - axial_hei, ((soulman_y + resident_y) / 2) - axial_wid, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((soulman_x + resident_x) / 2) - axial_hei
            line_end_y = ((soulman_y + resident_y) / 2) - axial_wid
            can.line(line_end_x, line_end_y, resident_x, resident_y)
            # Вычисление направления линии
            dx = resident_x - line_end_x
            dy = resident_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = resident_x
            arrow_tip_y = resident_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(resident_x, resident_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(resident_x, resident_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)

        # Резидент -> Душа-человек
        def resident_to_soulman():
            can.line(resident_x, resident_y, ((soulman_x + resident_x) / 2) + axial_hei, ((soulman_y + resident_y) / 2) - axial_wid)
            can.circle(((soulman_x + resident_x) / 2) + axial_hei, ((soulman_y + resident_y) / 2) - axial_wid, 2.5, stroke=0, fill=1)
            can.line(((soulman_x + resident_x) / 2) + axial_hei, ((soulman_y + resident_y) / 2) - axial_wid, ((soulman_x + resident_x) / 2) + axial_hei, ((soulman_y + resident_y) / 2) + axial_wid)
            can.circle(((soulman_x + resident_x) / 2) + axial_hei, ((soulman_y + resident_y) / 2) + axial_wid, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((soulman_x + resident_x) / 2) + axial_hei
            line_end_y = ((soulman_y + resident_y) / 2) + axial_wid
            can.line(line_end_x, line_end_y, soulman_x, soulman_y)
            # Вычисление направления линии
            dx = soulman_x - line_end_x
            dy = soulman_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = soulman_x
            arrow_tip_y = soulman_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(soulman_x, soulman_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(soulman_x, soulman_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)

        # Виртуоз -> Берсерк
        def virtuoso_to_berserker():
            can.line(virtuoso_x, virtuoso_y, ((virtuoso_x + berserker_x) / 2) - axial_hei, ((virtuoso_y + berserker_y) / 2) + axial_wid)
            can.circle(((virtuoso_x + berserker_x) / 2) - axial_hei, ((virtuoso_y + berserker_y) / 2) + axial_wid, 2.5, stroke=0, fill=1)
            can.line(((virtuoso_x + berserker_x) / 2) - axial_hei, ((virtuoso_y + berserker_y) / 2) + axial_wid, ((virtuoso_x + berserker_x) / 2) - axial_hei, ((virtuoso_y + berserker_y) / 2) - axial_wid)
            can.circle(((virtuoso_x + berserker_x) / 2) - axial_hei, ((virtuoso_y + berserker_y) / 2) - axial_wid, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((virtuoso_x + berserker_x) / 2) - axial_hei
            line_end_y = ((virtuoso_y + berserker_y) / 2) - axial_wid
            can.line(line_end_x, line_end_y, berserker_x, berserker_y)
            # Вычисление направления линии
            dx = berserker_x - line_end_x
            dy = berserker_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = berserker_x
            arrow_tip_y = berserker_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(berserker_x, berserker_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(berserker_x, berserker_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)

        # Берсерк -> Виртуоз
        def berserker_to_virtuoso():
            can.line(berserker_x, berserker_y, ((virtuoso_x + berserker_x) / 2) + axial_hei, ((virtuoso_y + berserker_y) / 2) - axial_wid)
            can.circle(((virtuoso_x + berserker_x) / 2) + axial_hei, ((virtuoso_y + berserker_y) / 2) - axial_wid, 2.5, stroke=0, fill=1)
            can.line(((virtuoso_x + berserker_x) / 2) + axial_hei, ((virtuoso_y + berserker_y) / 2) - axial_wid, ((virtuoso_x + berserker_x) / 2) + axial_hei, ((virtuoso_y + berserker_y) / 2) + axial_wid)
            can.circle(((virtuoso_x + berserker_x) / 2) + axial_hei, ((virtuoso_y + berserker_y) / 2) + axial_wid, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((virtuoso_x + berserker_x) / 2) + axial_hei
            line_end_y = ((virtuoso_y + berserker_y) / 2) + axial_wid
            can.line(line_end_x, line_end_y, virtuoso_x, virtuoso_y)
            # Вычисление направления линии
            dx = virtuoso_x - line_end_x
            dy = virtuoso_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = virtuoso_x
            arrow_tip_y = virtuoso_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(virtuoso_x, virtuoso_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(virtuoso_x, virtuoso_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)

        # Душа-человек -> Политик
        def soulman_to_politician():
            can.line(soulman_x, soulman_y, ((soulman_x + politician_x) / 2) - diagSmall_wid + diagSmall_hei, ((soulman_y + politician_y) / 2) + diagSmall_wid)
            can.circle(((soulman_x + politician_x) / 2) - diagSmall_wid + diagSmall_hei, ((soulman_y + politician_y) / 2) + diagSmall_wid, 2.5, stroke=0, fill=1)
            can.line(((soulman_x + politician_x) / 2) - diagSmall_wid + diagSmall_hei, ((soulman_y + politician_y) / 2) + diagSmall_wid, ((soulman_x + politician_x) / 2) + diagSmall_wid, ((soulman_y + politician_y) / 2) - diagSmall_wid + diagSmall_hei)
            can.circle(((soulman_x + politician_x) / 2) + diagSmall_wid, ((soulman_y + politician_y) / 2) - diagSmall_wid + diagSmall_hei, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((soulman_x + politician_x) / 2) + diagSmall_wid
            line_end_y = ((soulman_y + politician_y) / 2) - diagSmall_wid + diagSmall_hei
            can.line(line_end_x, line_end_y, politician_x, politician_y)
            # Вычисление направления линии
            dx = politician_x - line_end_x
            dy = politician_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = politician_x
            arrow_tip_y = politician_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(politician_x, politician_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(politician_x, politician_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)

        # Политик -> Душа-человек
        def politician_to_soulman():
            can.line(politician_x, politician_y, ((soulman_x + politician_x) / 2) + diagSmall_wid - diagSmall_hei, ((soulman_y + politician_y) / 2) - diagSmall_wid)
            can.circle(((soulman_x + politician_x) / 2) + diagSmall_wid - diagSmall_hei, ((soulman_y + politician_y) / 2) - diagSmall_wid, 2.5, stroke=0, fill=1)
            can.line(((soulman_x + politician_x) / 2) + diagSmall_wid - diagSmall_hei, ((soulman_y + politician_y) / 2) - diagSmall_wid, ((soulman_x + politician_x) / 2) - diagSmall_wid, ((soulman_y + politician_y) / 2) + diagSmall_wid - diagSmall_hei)
            can.circle(((soulman_x + politician_x) / 2) - diagSmall_wid, ((soulman_y + politician_y) / 2) + diagSmall_wid - diagSmall_hei, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((soulman_x + politician_x) / 2) - diagSmall_wid
            line_end_y = ((soulman_y + politician_y) / 2) + diagSmall_wid - diagSmall_hei
            can.line(line_end_x, line_end_y, soulman_x, soulman_y)
            # Вычисление направления линии
            dx = soulman_x - line_end_x
            dy = soulman_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = soulman_x
            arrow_tip_y = soulman_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(soulman_x, soulman_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(soulman_x, soulman_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)

        # Политик -> Берсерк
        def politician_to_berserker():
            can.line(politician_x, politician_y, ((politician_x + berserker_x) / 2) - diagSmall_wid + diagSmall_hei, ((politician_y + berserker_y) / 2) + diagSmall_wid)
            can.circle(((politician_x + berserker_x) / 2) - diagSmall_wid + diagSmall_hei, ((politician_y + berserker_y) / 2) + diagSmall_wid, 2.5, stroke=0, fill=1)
            can.line(((politician_x + berserker_x) / 2) - diagSmall_wid + diagSmall_hei, ((politician_y + berserker_y) / 2) + diagSmall_wid, ((politician_x + berserker_x) / 2) + diagSmall_wid, ((politician_y + berserker_y) / 2) - diagSmall_wid + diagSmall_hei)
            can.circle(((politician_x + berserker_x) / 2) + diagSmall_wid, ((politician_y + berserker_y) / 2) - diagSmall_wid + diagSmall_hei, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((politician_x + berserker_x) / 2) + diagSmall_wid
            line_end_y = ((politician_y + berserker_y) / 2) - diagSmall_wid + diagSmall_hei
            can.line(line_end_x, line_end_y, berserker_x, berserker_y)
            # Вычисление направления линии
            dx = berserker_x - line_end_x
            dy = berserker_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = berserker_x
            arrow_tip_y = berserker_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(berserker_x, berserker_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(berserker_x, berserker_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)

        # Берсерк -> Политик
        def berserker_to_politician():
            can.line(berserker_x, berserker_y, ((politician_x + berserker_x) / 2) + diagSmall_wid - diagSmall_hei, ((politician_y + berserker_y) / 2) - diagSmall_wid)
            can.circle(((politician_x + berserker_x) / 2) + diagSmall_wid - diagSmall_hei, ((politician_y + berserker_y) / 2) - diagSmall_wid, 2.5, stroke=0, fill=1)
            can.line(((politician_x + berserker_x) / 2) + diagSmall_wid - diagSmall_hei, ((politician_y + berserker_y) / 2) - diagSmall_wid, ((politician_x + berserker_x) / 2) - diagSmall_wid, ((politician_y + berserker_y) / 2) + diagSmall_wid - diagSmall_hei)
            can.circle(((politician_x + berserker_x) / 2) - diagSmall_wid, ((politician_y + berserker_y) / 2) + diagSmall_wid - diagSmall_hei, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((politician_x + berserker_x) / 2) - diagSmall_wid
            line_end_y = ((politician_y + berserker_y) / 2) + diagSmall_wid - diagSmall_hei
            can.line(line_end_x, line_end_y, politician_x, politician_y)
            # Вычисление направления линии
            dx = politician_x - line_end_x
            dy = politician_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = politician_x
            arrow_tip_y = politician_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(politician_x, politician_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(politician_x, politician_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)

        # Резидент -> Политик
        def resident_to_politician():
            can.line(resident_x, resident_y, ((resident_x + politician_x) / 2) - diagSmall_wid, ((resident_y + politician_y) / 2) - diagSmall_wid + diagSmall_hei)
            can.circle(((resident_x + politician_x) / 2) - diagSmall_wid, ((resident_y + politician_y) / 2) - diagSmall_wid + diagSmall_hei, 2.5, stroke=0, fill=1)
            can.line(((resident_x + politician_x) / 2) - diagSmall_wid, ((resident_y + politician_y) / 2) - diagSmall_wid + diagSmall_hei, ((resident_x + politician_x) / 2) + diagSmall_wid - diagSmall_hei, ((resident_y + politician_y) / 2) + diagSmall_wid)
            can.circle(((resident_x + politician_x) / 2) + diagSmall_wid - diagSmall_hei, ((resident_y + politician_y) / 2) + diagSmall_wid, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((resident_x + politician_x) / 2) + diagSmall_wid - diagSmall_hei
            line_end_y = ((resident_y + politician_y) / 2) + diagSmall_wid
            can.line(line_end_x, line_end_y, politician_x, politician_y)
            # Вычисление направления линии
            dx = politician_x - line_end_x
            dy = politician_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = politician_x
            arrow_tip_y = politician_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(politician_x, politician_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(politician_x, politician_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)

        # Политик -> Резидент
        def politician_to_resident():
            can.line(politician_x, politician_y, ((resident_x + politician_x) / 2) + diagSmall_wid, ((resident_y + politician_y) / 2) + diagSmall_wid - diagSmall_hei)
            can.circle(((resident_x + politician_x) / 2) + diagSmall_wid, ((resident_y + politician_y) / 2) + diagSmall_wid - diagSmall_hei, 2.5, stroke=0, fill=1)
            can.line(((resident_x + politician_x) / 2) + diagSmall_wid, ((resident_y + politician_y) / 2) + diagSmall_wid - diagSmall_hei, ((resident_x + politician_x) / 2) - diagSmall_wid + diagSmall_hei, ((resident_y + politician_y) / 2) - diagSmall_wid)
            can.circle(((resident_x + politician_x) / 2) - diagSmall_wid + diagSmall_hei, ((resident_y + politician_y) / 2) - diagSmall_wid, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((resident_x + politician_x) / 2) - diagSmall_wid + diagSmall_hei
            line_end_y = ((resident_y + politician_y) / 2) - diagSmall_wid
            can.line(line_end_x, line_end_y, resident_x, resident_y)
            # Вычисление направления линии
            dx = resident_x - line_end_x
            dy = resident_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = resident_x
            arrow_tip_y = resident_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(resident_x, resident_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(resident_x, resident_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)

        # Политик -> Виртуоз
        def politician_to_virtuoso():
            can.line(politician_x, politician_y, ((virtuoso_x + politician_x) / 2) - diagSmall_wid, ((virtuoso_y + politician_y) / 2) - diagSmall_wid + diagSmall_hei)
            can.circle(((virtuoso_x + politician_x) / 2) - diagSmall_wid, ((virtuoso_y + politician_y) / 2) - diagSmall_wid + diagSmall_hei, 2.5, stroke=0, fill=1)
            can.line(((virtuoso_x + politician_x) / 2) - diagSmall_wid, ((virtuoso_y + politician_y) / 2) - diagSmall_wid + diagSmall_hei, ((virtuoso_x + politician_x) / 2) + diagSmall_wid - diagSmall_hei, ((virtuoso_y + politician_y) / 2) + diagSmall_wid)
            can.circle(((virtuoso_x + politician_x) / 2) + diagSmall_wid - diagSmall_hei, ((virtuoso_y + politician_y) / 2) + diagSmall_wid, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((virtuoso_x + politician_x) / 2) + diagSmall_wid - diagSmall_hei
            line_end_y = ((virtuoso_y + politician_y) / 2) + diagSmall_wid
            can.line(line_end_x, line_end_y, virtuoso_x, virtuoso_y)
            # Вычисление направления линии
            dx = virtuoso_x - line_end_x
            dy = virtuoso_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = virtuoso_x
            arrow_tip_y = virtuoso_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(virtuoso_x, virtuoso_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(virtuoso_x, virtuoso_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)

        # Виртуоз -> Политик
        def virtuoso_to_politician():
            can.line(virtuoso_x, virtuoso_y, ((virtuoso_x + politician_x) / 2) + diagSmall_wid, ((virtuoso_y + politician_y) / 2) + diagSmall_wid - diagSmall_hei)
            can.circle(((virtuoso_x + politician_x) / 2) + diagSmall_wid, ((virtuoso_y + politician_y) / 2) + diagSmall_wid - diagSmall_hei, 2.5, stroke=0, fill=1)
            can.line(((virtuoso_x + politician_x) / 2) - diagSmall_wid + diagSmall_hei, ((virtuoso_y + politician_y) / 2) - diagSmall_wid, ((virtuoso_x + politician_x) / 2) + diagSmall_wid, ((virtuoso_y + politician_y) / 2) + diagSmall_wid - diagSmall_hei)
            can.circle(((virtuoso_x + politician_x) / 2) - diagSmall_wid + diagSmall_hei, ((virtuoso_y + politician_y) / 2) - diagSmall_wid, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((virtuoso_x + politician_x) / 2) - diagSmall_wid + diagSmall_hei
            line_end_y = ((virtuoso_y + politician_y) / 2) - diagSmall_wid
            can.line(line_end_x, line_end_y, politician_x, politician_y)
            # Вычисление направления линии
            dx = politician_x - line_end_x
            dy = politician_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = politician_x
            arrow_tip_y = politician_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(politician_x, politician_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(politician_x, politician_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)

        # Душа-человек -> Берсерк
        def soulman_to_berserker():
            can.line(soulman_x, soulman_y, ((soulman_x + berserker_x) / 2) - diagBig_wid + diagBig_hei, ((soulman_y + berserker_y) / 2) + diagBig_wid)
            can.circle(((soulman_x + berserker_x) / 2) - diagBig_wid + diagBig_hei, ((soulman_y + berserker_y) / 2) + diagBig_wid, 2.5, stroke=0, fill=1)
            can.line(((soulman_x + berserker_x) / 2) - diagBig_wid + diagBig_hei, ((soulman_y + berserker_y) / 2) + diagBig_wid, ((soulman_x + berserker_x) / 2) + diagBig_wid, ((soulman_y + berserker_y) / 2) - diagBig_wid + diagBig_hei)
            can.circle(((soulman_x + berserker_x) / 2) + diagBig_wid, ((soulman_y + berserker_y) / 2) - diagBig_wid + diagBig_hei, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((soulman_x + berserker_x) / 2) + diagBig_wid
            line_end_y = ((soulman_y + berserker_y) / 2) - diagBig_wid + diagBig_hei
            can.line(line_end_x, line_end_y, berserker_x, berserker_y)
            # Вычисление направления линии
            dx = berserker_x - line_end_x
            dy = berserker_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = berserker_x
            arrow_tip_y = berserker_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(berserker_x, berserker_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(berserker_x, berserker_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)

        # Берсерк -> Душа-человек
        def berserker_to_soulman():
            can.line(berserker_x, berserker_y, ((soulman_x + berserker_x) / 2) + diagBig_wid - diagBig_hei, ((soulman_y + berserker_y) / 2) - diagBig_wid)
            can.circle(((soulman_x + berserker_x) / 2) + diagBig_wid - diagBig_hei, ((soulman_y + berserker_y) / 2) - diagBig_wid, 2.5, stroke=0, fill=1)
            can.line(((soulman_x + berserker_x) / 2) + diagBig_wid - diagBig_hei, ((soulman_y + berserker_y) / 2) - diagBig_wid, ((soulman_x + berserker_x) / 2) - diagBig_wid, ((soulman_y + berserker_y) / 2) + diagBig_wid - diagBig_hei)
            can.circle(((soulman_x + berserker_x) / 2) - diagBig_wid, ((soulman_y + berserker_y) / 2) + diagBig_wid - diagBig_hei, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((soulman_x + berserker_x) / 2) - diagBig_wid
            line_end_y = ((soulman_y + berserker_y) / 2) + diagBig_wid - diagBig_hei
            can.line(line_end_x, line_end_y, soulman_x, soulman_y)
            # Вычисление направления линии
            dx = soulman_x - line_end_x
            dy = soulman_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = soulman_x
            arrow_tip_y = soulman_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(soulman_x, soulman_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(soulman_x, soulman_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)

        # Резидент -> Виртуоз
        def resident_to_virtuoso():
            can.line(resident_x, resident_y, ((virtuoso_x + resident_x) / 2) - diagBig_wid, ((virtuoso_y + resident_y) / 2) - diagBig_wid + diagBig_hei)
            can.circle(((virtuoso_x + resident_x) / 2) - diagBig_wid, ((virtuoso_y + resident_y) / 2) - diagBig_wid + diagBig_hei, 2.5, stroke=0, fill=1)
            can.line(((virtuoso_x + resident_x) / 2) - diagBig_wid, ((virtuoso_y + resident_y) / 2) - diagBig_wid + diagBig_hei, ((virtuoso_x + resident_x) / 2) + diagBig_wid - diagBig_hei, ((virtuoso_y + resident_y) / 2) + diagBig_wid)
            can.circle(((virtuoso_x + resident_x) / 2) + diagBig_wid - diagBig_hei, ((virtuoso_y + resident_y) / 2) + diagBig_wid, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((virtuoso_x + resident_x) / 2) + diagBig_wid - diagBig_hei
            line_end_y = ((virtuoso_y + resident_y) / 2) + diagBig_wid
            can.line(line_end_x, line_end_y, virtuoso_x, virtuoso_y)
            # Вычисление направления линии
            dx = virtuoso_x - line_end_x
            dy = virtuoso_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = virtuoso_x
            arrow_tip_y = virtuoso_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(virtuoso_x, virtuoso_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(virtuoso_x, virtuoso_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)

        # Виртуоз -> Резидент
        def virtuoso_to_resident():
            can.line(virtuoso_x, virtuoso_y, ((virtuoso_x + resident_x) / 2) + diagBig_wid, ((virtuoso_y + resident_y) / 2) + diagBig_wid - diagBig_hei)
            can.circle(((virtuoso_x + resident_x) / 2) + diagBig_wid, ((virtuoso_y + resident_y) / 2) + diagBig_wid - diagBig_hei, 2.5, stroke=0, fill=1)
            can.line(((virtuoso_x + resident_x) / 2) - diagBig_wid + diagBig_hei, ((virtuoso_y + resident_y) / 2) - diagBig_wid, ((virtuoso_x + resident_x) / 2) + diagBig_wid, ((virtuoso_y + resident_y) / 2) + diagBig_wid - diagBig_hei)
            can.circle(((virtuoso_x + resident_x) / 2) - diagBig_wid + diagBig_hei, ((virtuoso_y + resident_y) / 2) - diagBig_wid, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((virtuoso_x + resident_x) / 2) - diagBig_wid + diagBig_hei
            line_end_y = ((virtuoso_y + resident_y) / 2) - diagBig_wid
            can.line(line_end_x, line_end_y, resident_x, resident_y)
            # Вычисление направления линии
            dx = resident_x - line_end_x
            dy = resident_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = resident_x
            arrow_tip_y = resident_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(resident_x, resident_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(resident_x, resident_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)

        # Сортировка переменных из второго блока
        def sort_variables_2(adaptation_2, compromise_2, threat_2, cooperation_2, avoidance_2):
            # Собираем переменные в словарь
            variables = {
                'soulman': adaptation_2,
                'politician': compromise_2,
                'berserker': threat_2,
                'virtuoso': cooperation_2,
                'resident': avoidance_2
            }
            # Сортируем ключи по значениям в порядке убывания
            sorted_keys_2 = sorted(variables, key=variables.get, reverse=True)
            return sorted_keys_2, variables
            
        # Вызов функции sort_variables_2
        sorted_result, variables = sort_variables_2(adaptation_2, compromise_2, threat_2, cooperation_2, avoidance_2)
        # Проверяем переходы между значениями
        transitions = [
            (sorted_result[0], sorted_result[1]),
            (sorted_result[1], sorted_result[2]),
            (sorted_result[2], sorted_result[3]),
            (sorted_result[3], sorted_result[4]),
        ]
        # Цикл для перебора пар значений
        for pair in transitions:
            first, second = pair  # Разделяем пару на переменные
            # В зависимости от значений переменных вызываем разные функции
            if first == 'soulman' and second == 'virtuoso':
                soulman_to_virtuoso()
            if first == 'virtuoso' and second == 'soulman':
                virtuoso_to_soulman()
            if first == 'resident' and second == 'berserker':
                resident_to_berserker()
            if first == 'berserker' and second == 'resident':
                berserker_to_resident()
            if first == 'soulman' and second == 'resident':
                soulman_to_resident()
            if first == 'resident' and second == 'soulman':
                resident_to_soulman()
            if first == 'virtuoso' and second == 'berserker':
                virtuoso_to_berserker()
            if first == 'berserker' and second == 'virtuoso':
                berserker_to_virtuoso()
            if first == 'soulman' and second == 'politician':
                soulman_to_politician()
            if first == 'politician' and second == 'soulman':
                politician_to_soulman()
            if first == 'politician' and second == 'berserker':
                politician_to_berserker()
            if first == 'berserker' and second == 'politician':
                berserker_to_politician()
            if first == 'resident' and second == 'politician':
                resident_to_politician()
            if first == 'politician' and second == 'resident':
                politician_to_resident()
            if first == 'politician' and second == 'virtuoso':
                politician_to_virtuoso()
            if first == 'virtuoso' and second == 'politician':
                virtuoso_to_politician()
            if first == 'soulman' and second == 'berserker':
                soulman_to_berserker()
            if first == 'berserker' and second == 'soulman':
                berserker_to_soulman()
            if first == 'resident' and second == 'virtuoso':
                resident_to_virtuoso()
            if first == 'virtuoso' and second == 'resident':
                virtuoso_to_resident()

        can.showPage()  # Завершение пятой страницы


        # СТРАНИЦА 6
        image_path_6 = os.path.join(os.path.dirname(os.path.abspath(__file__)), "pagesPDF", "page_6.png")
        if not os.path.exists(image_path_6):
            print(f"Изображение {image_path_6} не найдено.")
            return
        can.drawImage(image_path_6, 0, 0, width=width, height=height)

        # ЗНАЧЕНИЯ РАЗБРОСА ЗНАЧЕНИЙ ПО КАТЕГОРИИ
        if userCategory is not None and userCategory != "-":

            cursor.execute("SELECT MIN(adaptation_2) FROM ISeC_results WHERE userCategory = ?", (userCategory,))  # SQL-запрос
            result_min = cursor.fetchone()  # Сохраняем результат в переменную  
            adaptation_2_min = result_min[0] if result_min else None  # Первая строка из результата запроса
            cursor.execute("SELECT MAX(adaptation_2) FROM ISeC_results WHERE userCategory = ?", (userCategory,))  # SQL-запрос
            result_max = cursor.fetchone()  # Сохраняем результат в переменную  
            adaptation_2_max = result_max[0] if result_max else None  # Первая строка из результата запроса
            if adaptation_2_min is not None and adaptation_2_max is not None:
                rangeSpreadHorizontal(adaptation_2_min, adaptation_2_max, 62.242, 532.995, 406.290, 36)

            cursor.execute("SELECT MIN(compromise_2) FROM ISeC_results WHERE userCategory = ?", (userCategory,))  # SQL-запрос
            result_min = cursor.fetchone()  # Сохраняем результат в переменную  
            compromise_2_min = result_min[0] if result_min else None  # Первая строка из результата запроса
            cursor.execute("SELECT MAX(compromise_2) FROM ISeC_results WHERE userCategory = ?", (userCategory,))  # SQL-запрос
            result_max = cursor.fetchone()  # Сохраняем результат в переменную  
            compromise_2_max = result_max[0] if result_max else None  # Первая строка из результата запроса
            if compromise_2_min is not None and compromise_2_max is not None:
                rangeSpreadHorizontal(compromise_2_min, compromise_2_max, 62.242, 532.995, 763.228, 36)

        # РЕЗУЛЬТАТ РЕСПОНДЕНТА
        if adaptation_2 is not None:
            rangeResultHorizontal(adaptation_2, 62.242, 532.995, 406.290, 36)
        if compromise_2 is not None:
            rangeResultHorizontal(compromise_2, 62.242, 532.995, 763.228, 36)

        can.showPage()  # Завершение шестой страницы


        # СТРАНИЦА 7
        image_path_7 = os.path.join(os.path.dirname(os.path.abspath(__file__)), "pagesPDF", "page_7.png")
        if not os.path.exists(image_path_7):
            print(f"Изображение {image_path_7} не найдено.")
            return
        can.drawImage(image_path_7, 0, 0, width=width, height=height)

        # ЗНАЧЕНИЯ РАЗБРОСА ЗНАЧЕНИЙ ПО КАТЕГОРИИ
        if userCategory is not None and userCategory != "-":

            cursor.execute("SELECT MIN(threat_2) FROM ISeC_results WHERE userCategory = ?", (userCategory,))  # SQL-запрос
            result_min = cursor.fetchone()  # Сохраняем результат в переменную  
            threat_2_min = result_min[0] if result_min else None  # Первая строка из результата запроса
            cursor.execute("SELECT MAX(threat_2) FROM ISeC_results WHERE userCategory = ?", (userCategory,))  # SQL-запрос
            result_max = cursor.fetchone()  # Сохраняем результат в переменную  
            threat_2_max = result_max[0] if result_max else None  # Первая строка из результата запроса
            if threat_2_min is not None and threat_2_max is not None:
                rangeSpreadHorizontal(threat_2_min, threat_2_max, 62.242, 532.995, 372.274, 36)

            cursor.execute("SELECT MIN(cooperation_2) FROM ISeC_results WHERE userCategory = ?", (userCategory,))  # SQL-запрос
            result_min = cursor.fetchone()  # Сохраняем результат в переменную  
            cooperation_2_min = result_min[0] if result_min else None  # Первая строка из результата запроса
            cursor.execute("SELECT MAX(cooperation_2) FROM ISeC_results WHERE userCategory = ?", (userCategory,))  # SQL-запрос
            result_max = cursor.fetchone()  # Сохраняем результат в переменную  
            cooperation_2_max = result_max[0] if result_max else None  # Первая строка из результата запроса
            if cooperation_2_min is not None and cooperation_2_max is not None:
                rangeSpreadHorizontal(cooperation_2_min, cooperation_2_max, 62.242, 532.995, 759.969, 36)

        # РЕЗУЛЬТАТ РЕСПОНДЕНТА
        if threat_2 is not None:
            rangeResultHorizontal(threat_2, 62.242, 532.995, 372.274, 36)
        if cooperation_2 is not None:
            rangeResultHorizontal(cooperation_2, 62.242, 532.995, 759.969, 36)

        can.showPage()  # Завершение седьмой страницы


        # СТРАНИЦА 8
        image_path_8 = os.path.join(os.path.dirname(os.path.abspath(__file__)), "pagesPDF", "page_8.png")
        if not os.path.exists(image_path_8):
            print(f"Изображение {image_path_8} не найдено.")
            return
        can.drawImage(image_path_8, 0, 0, width=width, height=height)

        # ЗНАЧЕНИЯ РАЗБРОСА ЗНАЧЕНИЙ ПО КАТЕГОРИИ
        if userCategory is not None and userCategory != "-":

            cursor.execute("SELECT MIN(avoidance_2) FROM ISeC_results WHERE userCategory = ?", (userCategory,))  # SQL-запрос
            result_min = cursor.fetchone()  # Сохраняем результат в переменную  
            avoidance_2_min = result_min[0] if result_min else None  # Первая строка из результата запроса
            cursor.execute("SELECT MAX(avoidance_2) FROM ISeC_results WHERE userCategory = ?", (userCategory,))  # SQL-запрос
            result_max = cursor.fetchone()  # Сохраняем результат в переменную  
            avoidance_2_max = result_max[0] if result_max else None  # Первая строка из результата запроса
            if avoidance_2_min is not None and avoidance_2_max is not None:
                rangeSpreadHorizontal(avoidance_2_min, avoidance_2_max, 62.242, 532.995, 405.865, 36)

        # РЕЗУЛЬТАТ РЕСПОНДЕНТА
        if avoidance_2 is not None:
            rangeResultHorizontal(avoidance_2, 62.242, 532.995, 405.865, 36)

        can.showPage()  # Завершение восьмой страницы


        # СТРАНИЦА 9
        image_path_9 = os.path.join(os.path.dirname(os.path.abspath(__file__)), "pagesPDF", "page_9.png")
        if not os.path.exists(image_path_9):
            print(f"Изображение {image_path_9} не найдено.")
            return
        can.drawImage(image_path_9, 0, 0, width=width, height=height)
        # Вычленяем значения из sorted_result[0] и sorted_result[4] для подсчёта разницы между минимумом и максимумом
        value_2_highest = variables[sorted_result[0]]
        value_2_lowest = variables[sorted_result[4]]
        value_2_subtraction = value_2_highest - value_2_lowest
        if value_2_subtraction < 10:
            can.drawString(257, height - 407.777, str(" " + str(value_2_subtraction)))  # Печатаем разницу с пробелом перед числом
        else:
            can.drawString(257, height - 407.777, str(value_2_subtraction))  # Печатаем разницу

        can.showPage()  # Завершение девятой страницы

        
        # СТРАНИЦА 10
        image_path_10 = os.path.join(os.path.dirname(os.path.abspath(__file__)), "pagesPDF", "page_10.png")
        if not os.path.exists(image_path_10):
            print(f"Изображение {image_path_10} не найдено.")
            return
        can.drawImage(image_path_10, 0, 0, width=width, height=height)

            # Функция рисования личного результата на вертикальной шкале
        def rangeResultVertical(range_name, range_y_start, range_y_end, range_x_start, range_divisionsCount):
            # Координаты
            x_start = range_x_start
            y_start = height - (range_y_start + (((range_y_end - range_y_start) / range_divisionsCount) * range_name))
            yTop = 4
            yBottom = -4
            xLeft = -20
            xCenter = -16
            xRight = -12
            can.setStrokeColorRGB(200 / 255, 65 / 255, 85 / 255)  # Устанавливаем цвет линии
            can.setLineWidth(1)  # Устанавливаем ширину линии
            can.setFillColorRGB(200 / 255, 65 / 255, 85 / 255) # Устанавливаем цвет заливки
            # Рисуем круг диаметром 1 пункт
            circle_radius = 0.5  # Радиус круга в пунктах
            can.circle(x_start, y_start, circle_radius, stroke=0, fill=1)  # Рисуем круг
            # Рисуем линию
            can.line(x_start, y_start, x_start + xRight, y_start)
            # Рисуем остальные элементы
            can.line(x_start + xRight, y_start, x_start + xCenter, y_start + yBottom)
            can.circle(x_start + xCenter, y_start + yBottom, circle_radius, stroke=0, fill=1)
            can.line(x_start + xCenter, y_start + yBottom, x_start + xLeft, y_start)
            can.circle(x_start + xLeft, y_start, circle_radius, stroke=0, fill=1)
            can.line(x_start + xLeft, y_start, x_start + xCenter, y_start + yTop)
            can.circle(x_start + xCenter, y_start + yTop, circle_radius, stroke=0, fill=1)
            can.line(x_start + xCenter, y_start + yTop, x_start + xRight, y_start)

            # Функция рисования разброса по категории на вертикальной шкале
        def rangeSpreadVertical(range_name_min, range_name_max, range_y_start, range_y_end, range_x_start, range_divisionsCount):
            # Координаты
            y_start_min = height - (range_y_start + (((range_y_end - range_y_start) / range_divisionsCount) * range_name_min))
            y_start_max = height - (range_y_start + (((range_y_end - range_y_start) / range_divisionsCount) * range_name_max))
            x_start = range_x_start
            # Координаты
            xTopLine = 10
            yCorner = 2
            xCorner = 5
            can.setStrokeColorRGB(90 / 255, 127 / 255, 174 / 255)  # Устанавливаем цвет линии
            can.setLineWidth(1)  # Устанавливаем ширину линии
            can.setFillColorRGB(90 / 255, 127 / 255, 174 / 255) # Устанавливаем цвет заливки
            circle_radius = 0.5  # Радиус круга в пунктах
            # НАЧАЛО ОТРЕЗКА
            can.circle(x_start, y_start_min, circle_radius, stroke=0, fill=1)  # Рисуется круг диаметром 1 пункт
            can.line(x_start, y_start_min, x_start - xCorner, y_start_min - yCorner)  # Рисуется линия
            can.circle(x_start - xCorner, y_start_min - yCorner, circle_radius, stroke=0, fill=1)
            can.line(x_start - xCorner, y_start_min - yCorner, x_start - xTopLine, y_start_min)
            can.circle(x_start - xTopLine, y_start_min, circle_radius, stroke=0, fill=1)
            # КОНЕЦ ОТРЕЗКА
            can.circle(x_start, y_start_max, circle_radius, stroke=0, fill=1)  # Рисуется круг диаметром 1 пункт
            can.line(x_start, y_start_max, x_start - xCorner, y_start_max + yCorner)  # Рисуется линия
            can.circle(x_start - xCorner, y_start_max + yCorner, circle_radius, stroke=0, fill=1)
            can.line(x_start - xCorner, y_start_max + yCorner, x_start - xTopLine, y_start_max)
            can.circle(x_start - xTopLine, y_start_max, circle_radius, stroke=0, fill=1)
            # СОЕДИНИТЕЛЬНАЯ ЛИНИЯ
            can.line(x_start - xTopLine, y_start_min, x_start - xTopLine, y_start_max)

        # ЗНАЧЕНИЯ РАЗБРОСА ЗНАЧЕНИЙ ПО КАТЕГОРИИ
        if userCategory is not None and userCategory != "-":

            cursor.execute("SELECT MIN(adaptation_3) FROM ISeC_results WHERE userCategory = ?", (userCategory,))  # SQL-запрос
            result_min = cursor.fetchone()  # Сохраняем результат в переменную  
            adaptation_3_min = result_min[0] if result_min else None  # Первая строка из результата запроса
            cursor.execute("SELECT MAX(adaptation_3) FROM ISeC_results WHERE userCategory = ?", (userCategory,))  # SQL-запрос
            result_max = cursor.fetchone()  # Сохраняем результат в переменную  
            adaptation_3_max = result_max[0] if result_max else None  # Первая строка из результата запроса
            if adaptation_3_min is not None and adaptation_3_max is not None:
                rangeSpreadVertical(adaptation_3_min, adaptation_3_max, 779.91, 312.05, 391.33, 27)

            cursor.execute("SELECT MIN(threat_3) FROM ISeC_results WHERE userCategory = ?", (userCategory,))  # SQL-запрос
            result_min = cursor.fetchone()  # Сохраняем результат в переменную  
            threat_3_min = result_min[0] if result_min else None  # Первая строка из результата запроса
            cursor.execute("SELECT MAX(threat_3) FROM ISeC_results WHERE userCategory = ?", (userCategory,))  # SQL-запрос
            result_max = cursor.fetchone()  # Сохраняем результат в переменную  
            threat_3_max = result_max[0] if result_max else None  # Первая строка из результата запроса
            if threat_3_min is not None and threat_3_max is not None:
                rangeSpreadVertical(threat_3_min, threat_3_max, 779.91, 312.05, 455.11, 27)

            cursor.execute("SELECT MIN(cooperation_3) FROM ISeC_results WHERE userCategory = ?", (userCategory,))  # SQL-запрос
            result_min = cursor.fetchone()  # Сохраняем результат в переменную  
            cooperation_3_min = result_min[0] if result_min else None  # Первая строка из результата запроса
            cursor.execute("SELECT MAX(cooperation_3) FROM ISeC_results WHERE userCategory = ?", (userCategory,))  # SQL-запрос
            result_max = cursor.fetchone()  # Сохраняем результат в переменную  
            cooperation_3_max = result_max[0] if result_max else None  # Первая строка из результата запроса
            if cooperation_3_min is not None and cooperation_3_max is not None:
                rangeSpreadVertical(cooperation_3_min, cooperation_3_max, 779.91, 312.05, 518.889, 27)

        # РЕЗУЛЬТАТ РЕСПОНДЕНТА
        if adaptation_3 is not None:
            rangeResultVertical(adaptation_3, 779.91, 312.05, 391.33, 27)
        if threat_3 is not None:
            rangeResultVertical(threat_3, 779.91, 312.05, 455.11, 27)
        if cooperation_3 is not None:
            rangeResultVertical(cooperation_3, 779.91, 312.05, 518.889, 27)

        can.showPage()  # Завершение десятой страницы


        # СТРАНИЦА 11
        image_path_11 = os.path.join(os.path.dirname(os.path.abspath(__file__)), "pagesPDF", "page_11.png")
        if not os.path.exists(image_path_11):
            print(f"Изображение {image_path_11} не найдено.")
            return
        can.drawImage(image_path_11, 0, 0, width=width, height=height)

        can.showPage()  # Завершение одиннадцатой страницы


        # СТРАНИЦА 12
        image_path_12 = os.path.join(os.path.dirname(os.path.abspath(__file__)), "pagesPDF", "page_12.png")
        if not os.path.exists(image_path_12):
            print(f"Изображение {image_path_12} не найдено.")
            return
        can.drawImage(image_path_12, 0, 0, width=width, height=height)

        can.showPage()  # Завершение двенадцатой страницы


        # СТРАНИЦА 13
        image_path_13 = os.path.join(os.path.dirname(os.path.abspath(__file__)), "pagesPDF", "page_13.png")
        if not os.path.exists(image_path_13):
            print(f"Изображение {image_path_13} не найдено.")
            return
        can.drawImage(image_path_13, 0, 0, width=width, height=height)
        can.drawString(249.658, height - 254.288, str(strengthInstallation_4))  # Силовая модель
        can.drawString(231.398, height - 287.888, str(manipulationInstallation_4))  # Манипулятивная модель
        can.drawString(250.429, height - 321.496, str(negotiationsInstallation_4))  # Деловая модель
        understandingPercentage = understandingOfStyles_4 * 100 / 30
        if (understandingPercentage).is_integer():
            can.drawString(189.178, height - 355.088, f"{int(understandingPercentage)}%")  # Понимание стилей целое, выводим без десятичных
        else:
            can.drawString(189.178, height - 355.088, f"{(understandingPercentage) :.2f}%")  # Понимание стилей дробное, выводим с двумя знаками
        # Устанавливаем начальные и конечные координаты графика
        start_x_tactics = 56.693
        start_y_tactics = height - 412.522
        end_x_tactics = 538.583
        width_tactics = 44.184
        # Определяем ширину графика, которую мы будем использовать
        fullWidth_tactics = end_x_tactics - start_x_tactics
        # Определяем значения для каждой части графика
        values_tactics = [
            {"name": "Силовая", "color": (200/255, 65/255, 85/255), "value": strengthInstallation_4},
            {"name": "Манипулятивная", "color": (90/255, 127/255, 174/255), "value": manipulationInstallation_4},
            {"name": "Деловая", "color": (235/255, 188/255, 109/255), "value": negotiationsInstallation_4},
        ]
        # Начальная позиция по X для рисования в цикле for каждой части графика
        current_x_tactics = start_x_tactics
        # График
        for part_tactics in values_tactics:
            if part_tactics["value"] > 0:  # Проверяем, что значение больше 0
                # Рассчитывается ширина на основе значения
                width_tactics_value = (fullWidth_tactics * part_tactics["value"]) / sum(part["value"] for part in values_tactics)
                can.setStrokeColorRGB(*part_tactics["color"])
                can.setLineWidth(width_tactics)
                can.line(current_x_tactics, start_y_tactics, current_x_tactics + width_tactics_value, start_y_tactics)
                current_x_tactics += width_tactics_value  # Увеличиваем текущую позицию по X

        can.showPage()  # Завершение тринадцатой страницы


        # СТРАНИЦА 14
        image_path_14 = os.path.join(os.path.dirname(os.path.abspath(__file__)), "pagesPDF", "page_14.png")
        if not os.path.exists(image_path_14):
            print(f"Изображение {image_path_14} не найдено.")
            return
        can.drawImage(image_path_14, 0, 0, width=width, height=height)

        can.showPage()  # Завершение четырнадцатой страницы


        # СТРАНИЦА 15
        image_path_15 = os.path.join(os.path.dirname(os.path.abspath(__file__)), "pagesPDF", "page_15.png")
        if not os.path.exists(image_path_15):
            print(f"Изображение {image_path_15} не найдено.")
            return
        can.drawImage(image_path_15, 0, 0, width=width, height=height)

        can.showPage()  # Завершение пятнадцатой страницы


        # СТРАНИЦА 16
        image_path_16 = os.path.join(os.path.dirname(os.path.abspath(__file__)), "pagesPDF", "page_16.png")
        if not os.path.exists(image_path_16):
            print(f"Изображение {image_path_16} не найдено.")
            return
        can.drawImage(image_path_16, 0, 0, width=width, height=height)

        # ЗНАЧЕНИЯ РАЗБРОСА ЗНАЧЕНИЙ ПО КАТЕГОРИИ
        if userCategory is not None and userCategory != "-":

            cursor.execute("SELECT MIN(logicArgument_6) FROM ISeC_results WHERE userCategory = ?", (userCategory,))  # SQL-запрос
            result_min = cursor.fetchone()  # Сохраняем результат в переменную  
            logicArgument_6_min = result_min[0] if result_min else None  # Первая строка из результата запроса
            cursor.execute("SELECT MAX(logicArgument_6) FROM ISeC_results WHERE userCategory = ?", (userCategory,))  # SQL-запрос
            result_max = cursor.fetchone()  # Сохраняем результат в переменную  
            logicArgument_6_max = result_max[0] if result_max else None  # Первая строка из результата запроса
            if logicArgument_6_min is not None and logicArgument_6_max is not None:
                rangeSpreadHorizontal(logicArgument_6_min, logicArgument_6_max, 63.27, 532, 458.646, 30)

            cursor.execute("SELECT MIN(emotionsArgument_6) FROM ISeC_results WHERE userCategory = ?", (userCategory,))  # SQL-запрос
            result_min = cursor.fetchone()  # Сохраняем результат в переменную  
            emotionsArgument_6_min = result_min[0] if result_min else None  # Первая строка из результата запроса
            cursor.execute("SELECT MAX(emotionsArgument_6) FROM ISeC_results WHERE userCategory = ?", (userCategory,))  # SQL-запрос
            result_max = cursor.fetchone()  # Сохраняем результат в переменную  
            emotionsArgument_6_max = result_max[0] if result_max else None  # Первая строка из результата запроса
            if emotionsArgument_6_min is not None and emotionsArgument_6_max is not None:
                rangeSpreadHorizontal(emotionsArgument_6_min, emotionsArgument_6_max, 63.27, 532, 762.315, 30)

        # РЕЗУЛЬТАТ РЕСПОНДЕНТА
        if logicArgument_6 is not None:
            rangeResultHorizontal(logicArgument_6, 63.27, 532, 458.646, 30)
        if emotionsArgument_6 is not None:
            rangeResultHorizontal(emotionsArgument_6, 63.27, 532, 762.315, 30)

        can.showPage()  # Завершение шестнадцатой страницы


        # СТРАНИЦА 17
        image_path_17 = os.path.join(os.path.dirname(os.path.abspath(__file__)), "pagesPDF", "page_17.png")
        if not os.path.exists(image_path_17):
            print(f"Изображение {image_path_17} не найдено.")
            return
        can.drawImage(image_path_17, 0, 0, width=width, height=height)
        # Цвет шкал
        scale_color_red = (200/255, 65/255, 85/255)
        scale_color_blue = (90/255, 127/255, 174/255)
        def scalesIntegr(color, scale_y_height, result, total):
            # Общие параметры шкал
            csale_width = 26.701
            csale_x_start = 103.919
            csale_x_end = 527.945
            csale_filling = csale_x_start + (result / total) * (csale_x_end - csale_x_start)
            # Рисование шкалы
            can.setStrokeColor(color)
            can.setLineWidth(csale_width)
            can.line(csale_x_start, scale_y_height, csale_filling, scale_y_height)
        # Параметры шкалы "приспособление"
        scalesIntegr(scale_color_red, height-321.543, adaptationCount, 29)
        # Параметры шкалы "компромисс"
        scalesIntegr(scale_color_blue, height-360.877, compromiseCount, 17)
        # Параметры шкалы "торги"
        scalesIntegr(scale_color_red, height-400.261, biddingCount, 15)
        # Параметры шкалы "угроза"
        scalesIntegr(scale_color_blue, height-439.644, threatCount, 26)
        # Параметры шкалы "логика как аргумент"
        scalesIntegr(scale_color_red, height-479.028, logicArgumentCount, 23)
        # Параметры шкалы "эмоции как аргумент"
        scalesIntegr(scale_color_blue, height-518.412, emotionsArgumentCount, 26)
        # Параметры шкалы "понимание стилей"
        scalesIntegr(scale_color_red, height-557.795, understandingOfStyles_4, 32)
        # Параметры шкалы "установка на силу"
        scalesIntegr(scale_color_blue, height-597.179, strengthInstallationCount, 16)
        # Параметры шкалы "установка на манипуляцию"
        scalesIntegr(scale_color_red, height-636.563, manipulationInstallationCount, 16)
        # Параметры шкалы "установка на деловые переговоры"
        scalesIntegr(scale_color_blue, height-675.946, negotiationsInstallationCount, 16)
        # Параметры шкалы "сотрудничество"
        scalesIntegr(scale_color_red, height-715.330, cooperationCount, 21)
        # Параметры шкалы "избегание"
        scalesIntegr(scale_color_blue, height-754.714, avoidanceCount, 16)

        can.showPage()  # Завершение семнадцатой страницы


        # Сохранение документа
        can.save()
        print(f"PDF-файл успешно создан: {pdf_path}")

        
        # Проверка на существование записи с данным userId
        cursor.execute("SELECT COUNT(*) FROM ISeC_results WHERE userId = ?", (userId,))
        exists = cursor.fetchone()[0] > 0

        if exists:
            print("Данные уже существуют в базе")  # Выводим сообщение в консоль, если запись уже существует
        else:

            # SQL-запрос для вставки данных
            sql = '''INSERT INTO ISeC_results (
                userId, userGroup, userName, userSurname, userSex, userBirthyear, userCategory, userEmail,
                adaptation_1, compromise_1, bidding_1, threat_1, logicArgument_1, emotionsArgument_1,
                adaptationCount_1, compromiseCount_1, biddingCount_1, threatCount_1, logicArgumentCount_1, emotionsArgumentCount_1,
                adaptation_2, compromise_2, threat_2, cooperation_2, avoidance_2,
                adaptationCount_2, compromiseCount_2, threatCount_2, cooperationCount_2, avoidanceCount_2,
                adaptation_3, threat_3, cooperation_3,
                adaptationCount_3,  threatCount_3, cooperationCount_3,
                understandingOfStyles_4, strengthInstallation_4, manipulationInstallation_4,  negotiationsInstallation_4,
                strengthInstallationCount_4, manipulationInstallationCount_4, negotiationsInstallationCount_4,
                adaptation_5, bidding_5, logicArgument_5, emotionsArgument_5, avoidance_5,
                adaptationCount_5, biddingCount_5, logicArgumentCount_5, emotionsArgumentCount_5, avoidanceCount_5,
                logicArgument_6, emotionsArgument_6,
                logicArgumentCount_6, emotionsArgumentCount_6
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,
            ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'''

            # Выполнение запроса с передачей значений
            cursor.execute(sql, (
                userId, userGroup, userName, userSurname,  userSex, userBirthyear, userCategory, userEmail,
                adaptation_1, compromise_1, bidding_1,  threat_1,  logicArgument_1, emotionsArgument_1,
                adaptationCount_1, compromiseCount_1, biddingCount_1,  threatCount_1, logicArgumentCount_1, emotionsArgumentCount_1,
                adaptation_2, compromise_2, threat_2,  cooperation_2,  avoidance_2,
                adaptationCount_2, compromiseCount_2, threatCount_2,  cooperationCount_2, avoidanceCount_2,
                adaptation_3,  threat_3,  cooperation_3,
                adaptationCount_3, threatCount_3,  cooperationCount_3,
                understandingOfStyles_4, strengthInstallation_4,  manipulationInstallation_4,  negotiationsInstallation_4,
                strengthInstallationCount_4, manipulationInstallationCount_4,  negotiationsInstallationCount_4,
                adaptation_5, bidding_5, logicArgument_5,  emotionsArgument_5, avoidance_5,
                adaptationCount_5, biddingCount_5, logicArgumentCount_5,  emotionsArgumentCount_5, avoidanceCount_5,
                logicArgument_6, emotionsArgument_6,
                logicArgumentCount_6, emotionsArgumentCount_6
            ))
            
        # Сохранение изменений и закрытие соединения
        conn.commit()
        conn.close()